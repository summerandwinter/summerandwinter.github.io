<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>学习Git | Winter`s Notes</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="canonical" href="https://summerandwinter.github.io/learn-git.html"><meta name="description" content="介绍一些Git学习过程中入门的基本知识"><meta name="keywords" content="Git"><meta property="og:type" content="article"><meta property="og:title" content="学习Git"><meta property="og:url" content="https://summerandwinter.github.io/learn-git.html"><meta property="og:site_name" content="Winter`s Notes"><meta property="og:description" content="介绍一些Git学习过程中入门的基本知识"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/summerandwinter/summerandwinter.github.io/assets/images/articles/git_workflow.svg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/summerandwinter/summerandwinter.github.io/assets/images/articles/git-diagram-3.svg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/summerandwinter/summerandwinter.github.ioassets/images/articles/git-diagram-1.svg"><meta property="og:updated_time" content="2019-11-28T08:58:49.415Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="学习Git"><meta name="twitter:description" content="介绍一些Git学习过程中入门的基本知识"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/summerandwinter/summerandwinter.github.io/assets/images/articles/git_workflow.svg"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/summerandwinter/summerandwinter.github.io/css/gitment.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/summerandwinter/summerandwinter.github.io/css/article.css"></head></html><body><div id="container"><div id="wrap"><header id="header" class="header"><nav id="main-nav" class="main-nav"> <a class="main-nav-link" href="/">主页</a> <a class="main-nav-link" href="/archives">归档</a> <a class="main-nav-link" href="/category">分类</a> <a class="main-nav-link" href="/tag">标签</a></nav><nav id="sub-nav"></nav></header><div class="outer"><section id="main"><div class="article-container"><article id="post-learn-git" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name"> 学习Git</h1></header><div class="article-entry typo" itemprop="articleBody"><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>首先介绍一些关于Git的基本概念，方便后面的学习。<br>Git中有三种状态：</p><ol><li><code>已提交（commited）</code> 表示数据已安全的保存在本地数据库中。</li><li><code>已修改（modified）</code> 表示修改了文件，还没保存到本地数据库中。</li><li><code>已暂存（staged）</code> 表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li></ol><p>由此可以把一个Git项目看作由三部分组成</p><ol><li><code>工作目录</code>（Working Directory）<br>顾名思义这里就是我们的工作区域，可以这样理解，在这里我们不用分心去考虑版本控制的事，只用专心完成自己工作，因为这里的内容只是整个项目的某一个版本，我们可以放心的修改而不用担心对其他版本产生影响。</li><li><code>暂存区</code>（Staging Area）<br>实际上它只是一个文件，通常情况下这个文件在仓库目录中，它的作用是告诉Git在下次执行<code>commit</code>时需要放入仓库的内容。我们可以把它理解为我们在工作目录对文件所做改动的一个索引。</li><li><code>仓库</code>（Repository）<br>Git 用来保存项目的元数据和对象数据库的地方，通过这种方式来永久保存项目中不同版本的内容。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</li></ol><p>Git的工作流程大致是：</p><ol><li><p>在工作目录中修改文件。</p></li><li><p>暂存文件，将文件的快照放入暂存区域。</p></li><li><p>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库。</p></li></ol><p><img src="//cdn.jsdelivr.net/gh/summerandwinter/summerandwinter.github.io/assets/images/articles/git_workflow.svg" alt="Git工作流程"></p><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ol><li><p><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 <code>--system</code> 选项的 <code>git config</code>时，它会从此文件读写配置变量。</p></li><li><p><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。</p></li><li><p>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是 .git/config）：针对该仓库。<br>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。</p></li></ol><blockquote><p>在 Windows 系统中，Git 会查找 $HOME 目录下（一般情况下是 C:\Users\$USER）的 .gitconfig 文件。 Git 同样也会寻找 /etc/gitconfig 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。</p></blockquote><p>配置用户信息<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"winter"</span></span><br><span class="line">git config --global user.email winter@example.com</span><br></pre></td></tr></table></figure><p></p><p>配置文本编辑器<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.editor emacs</span><br></pre></td></tr></table></figure><p></p><p>检查配置信息<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p></p><p>或者只检查某一项<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure><p></p><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>Git通过 <code>.gitignore</code> 文件来管理需要忽略的文件模式，我们通过一些规则来告诉Git哪些文件不需要列入追踪列表。<br>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>#</code> 开头的行都会被 <code>Git</code> 忽略。</li><li>可以使用标准的 <code>glob</code> 模式匹配。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul><p>所谓的 <code>glob</code> 模式是指 <code>shell</code> 所使用的简化了的正则表达式。</p><ul><li><code>*</code>星号匹配零个或多个任意字符；</li><li><code>[abc]</code> 匹配任何一个方括号中的字符（要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；</li><li><code>?</code> 问号只匹配一个任意字符；</li><li><code>[0-9]</code> 如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。</li><li><code>**</code> 使用两个星号表示匹配任意中间目录，比如a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z等。</li></ul><p>下面我们看一个 <code>.gitignore</code> 文件的例子加深理解：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 忽略 .a 后缀的文件</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尽管上面忽略的 .a 后缀的文件，但是要追踪 lib.a 文件</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只忽略当前目录下的 TODO 文件，子目录下的 TODO 文件继续追踪</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc 目录下的 .txt 文件，但是不忽略子目录下的 .txt 文件 如：忽略 doc/notes.txt, 但是不忽略 doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc 目录下所有的 .pdf 文件，包括子目录下的 .pdf 文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><p></p><blockquote><p>GitHub 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表，你可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> 找到它.</p></blockquote><h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2><p>有三种方法可以找到 Git 命令的使用手册：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">help</span> &lt;verb&gt;</span><br><span class="line">git &lt;verb&gt; --<span class="built_in">help</span></span><br><span class="line">man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure><p></p><p>例如，要想获得 config 命令的手册，执行<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">help</span> config</span><br></pre></td></tr></table></figure><p></p><h2 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h2><ul><li>在现有目录中初始化仓库</li></ul><p>使用 <code>git init</code> 初始化，创建一个新的Git仓库</p><p>在你的工作目录下创建一个名为 <code>learngit</code> 的目录，并切换到该目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir learngit</span><br><span class="line"><span class="built_in">cd</span> learngit</span><br></pre></td></tr></table></figure><p>执行<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p></p><p>到这一步初始化的工作就完成了</p><ul><li>克隆现有的仓库</li></ul><p>克隆仓库的命令格式是 <code>git clone [url]</code> 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/libgit2/libgit2</span><br></pre></td></tr></table></figure><p></p><p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span><br></pre></td></tr></table></figure><p></p><p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 mylibgit。</p><p>Git 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code> 协议，不过你也可以使用 <code>git://</code> 协议或者使用 <code>SSH</code>传输协议，比如 <code>user@server:path/to/repo.git</code> 。</p><h1 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h1><p>在工作目录中新建一个文件<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano readme.txt</span><br></pre></td></tr></table></figure><p></p><p>添加一行文字<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is demo for git learning</span><br></pre></td></tr></table></figure><p></p><h2 id="检查状态"><a href="#检查状态" class="headerlink" title="检查状态"></a>检查状态</h2><p>使用 <code>git status</code> 检查工作区和暂存区的内容（文件状态）</p><p>现在工作目录有一个新的文件 <code>readme.txt</code> 但是还没有提交到暂存区</p><p>执行 <code>git status</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">        readme.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure><p>从上面终端中打印的信息可以注意到<code>Untracked files:</code>下面的<code>readme.txt</code>,<code>Untracked</code> （未跟踪）表示Git已经看到这个文件，但是还没有开始跟踪这个文件的变化。</p><p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种更为紧凑的格式输出。</p><p>运行 <code>git status -s</code> ，状态报告输出如下：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status -s</span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure><p></p><p><code>??</code> 新添加的未跟踪文件<br><code>A</code> 新添加到暂存区中的文件，<br><code>M</code> 修改过的文件</p><blockquote><p><code>M</code> 有两个可以出现的位置，出现在右边的 <code>M</code> 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 <code>M</code> 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： <code>README</code> 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,<code>lib/simplegit.rb</code> 文件被修改了并将修改后的文件放入了暂存区。 而 <code>Rakefile</code> 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p></blockquote><h2 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h2><p>使用命令 <code>git add</code> 开始跟踪一个文件。<br>执行<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure><p></p><p>我们再来查看状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   readme.txt</span><br></pre></td></tr></table></figure><p>从<code>new file: readme.txt</code> 可以看出 <code>readme.txt</code> 已经加入暂存区了，现在文件已处于 <code>tracked</code> （已跟踪）状态，从现在开始Git将跟踪它的每一次改动。</p><ul><li><code>git diff</code> 比较工作区和暂存区的差异</li></ul><h2 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h2><p>在 <code>readme.txt</code> 文件中加入另外一行文字<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">This is another line</span><br></pre></td></tr></table></figure><p></p><p>执行<code>git diff</code>命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index b35e311..60520a0 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line">-This is demo <span class="keyword">for</span> git learning</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+This is demo <span class="keyword">for</span> git learning</span><br><span class="line">+This is another line</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>使用 <code>git diff</code> 命令可以检查文件在工作目录和暂存区中的差别。<br>从打印信息可以看出，工作目录中 <code>readme.txt</code> 的内容（ <code>+</code> 标记）比暂存区（ <code>-</code> 标记）的内容多出了我们刚添加的一行。</p><blockquote><p>PS: 按键盘上的 <code>q</code> 可以退出 diff 模式</p></blockquote><p>现在我们来修改这个已被跟踪的文件<br>执行<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add readme.txt</span><br></pre></td></tr></table></figure><p></p><p>要暂存这次更新，需要运行 git add 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。</p><h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><p> <code>git commit</code> 把暂存区文件的改动提交到仓库</p><p><code>commit</code> 是这里说的Git工作流程的最后一步，该命令会把已跟踪的文件的改动永久的保存到仓库。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"Complete my first commit"</span></span><br></pre></td></tr></table></figure><p>需要注意的是 <code>commit</code> 需要配合 <code>-m</code>选项一起使用来备注每一次提交。通常我们会约定备注信息要满足下列几个条件</p><ul><li>必须用引号引起来</li><li>用现代时书写备注</li><li>简明扼要（不超过50个字符）</li></ul><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m <span class="string">'added new benchmarks'</span></span><br></pre></td></tr></table></figure><p></p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p></p><p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p><p>执行上面命令会启动编辑器打开你上一次提交的备注信息，编辑后保存会覆盖原来的提交信息。</p><p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">'initial commit'</span></span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p></p><p>最终你只会有一个提交 - 第二次提交将代替上一次提交的结果。</p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><ul><li><code>git log</code> 列出所有的提交历时</li></ul><p>执行 <code>git log</code> 命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">commit 12385fd24ad0cadb2ca6ed4488caae153e3d23b9</span><br><span class="line">Author: winter &lt;summerandwiner@gmail.com&gt;</span><br><span class="line">Date:   Fri Dec 9 02:55:43 2016 -0500  </span><br><span class="line"></span><br><span class="line">	Complete first line of commit</span><br></pre></td></tr></table></figure><p>从终端打印的文本我们可以看到下面的信息：</p><ul><li>一段40个字符的字符串（12385fd24ad0cadb2ca6ed4488caae153e3d23b9），我们把它称之为 <code>SHA</code>, Git用它来标识每一次提交的唯一性。</li><li>提交的用户</li><li>提交的日期和时间</li><li>提交的备注信息</li></ul><h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm PROJECTS.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        deleted:    PROJECTS.md</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p></p><p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm PROJECTS.md</span><br><span class="line">rm <span class="string">'PROJECTS.md'</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    deleted:    PROJECTS.md</span><br></pre></td></tr></table></figure><p></p><p>下一次提交时，该文件就不再纳入版本管理了。 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 <code>Git</code> 继续跟踪。 当你忘记添加 <code>.gitignore</code>文件，不小心把一个很大的日志文件或一堆 <code>.a</code> 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 <code>--cached</code> 选项：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm --cached README</span><br></pre></td></tr></table></figure><p></p><p><code>git rm</code> 命令后面可以列出文件或者目录的名字，也可以使用 <code>glob</code> 模式。 比方说：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm <span class="built_in">log</span>/\*.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p></p><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>， 因为 <code>Git</code>有它自己的文件模式扩展匹配方式，所以我们不用 <code>shell</code> 来帮忙展开。 此命令删除 log/ 目录下扩展名为 <code>.log</code> 的所有文件。 类似的比如：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm \*~</span><br></pre></td></tr></table></figure><p></p><p>该命令为删除以 <code>~</code> 结尾的所有文件。</p><h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p><p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git mv file_from file_to</span><br></pre></td></tr></table></figure><p></p><p>它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git mv README.md README</span><br><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure><p></p><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv README.md README</span><br><span class="line">git rm README.md</span><br><span class="line">git add README</span><br></pre></td></tr></table></figure><p></p><p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式结果都一样。 两者唯一的区别是，<code>mv</code> 是一条命令而另一种方式需要三条命令，直接用 <code>git mv</code> 轻便得多。 不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p><h1 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h1><p>在使用Git时，我们经常会遇到一些情况需要撤销我们所做的一些修改，Git提供了一些这样的特性。<br>首先我们需要了解一个概念，Git把 <code>HEAD</code> 提交作为我们正在进行的提交，大部分情况下最新的提交就是 <code>HEAD</code> 提交。<br>使用下面的命令查看 <code>HEAD</code> 提交<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show HEAD</span><br></pre></td></tr></table></figure><p></p><h2 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h2><p>假设我们对工作目录中的 <code>readme.txt</code> 做了一些改动，但是现在我们想要放弃这些改动恢复到改动之前的样子，但是我们已经忘记了改动之前是什么样子了，下面的命令可以使工作目录中的 <code>readme.txt</code> 文件恢复到你最近一次提交时的样子</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout HEAD readme.txt</span><br><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p>上面两个命令可以达到相同的效果。</p><p><strong>IMPORTANT</strong><br><code>git checkout -- [file]</code> <strong>是一个危险的命令</strong>，执行命令后我们对那个文件做的任何修改都会消失，且<strong>不可恢复</strong>，因为Git只是拷贝仓库中最后一次提交的文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。</p><blockquote><p>记住，在 Git 中任何 已提交的 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 <code>--amend</code>选项覆盖的提交也可以恢复。 然而，任何你未提交的东西丢失后很可能再也找不到了。</p></blockquote><h2 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h2><p>假设一种情况，我们不小心把上面对 <code>readme.txt</code> 的改动添加到了暂存区，但是现在我们现在还不想提交这个改动。Git 中可以通过 <code>git reset</code> 命令把某个文件在暂存区中移除。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD readme.txt</span><br></pre></td></tr></table></figure><p>上面的命令实际上是把暂存区的 <code>readme.txt</code> 文件重置到与 <code>HEAD</code> 提交中的相同来达到从暂存区移除的效果，假如我们对 <code>readme.txt</code> 文件做了两个改动，并分两次添加到暂存区，执行命令后，这两次的提交都会在暂存区消失。<br>它只会重置暂存区的文件，不会影响工作目录中的文件。<br>类似的，如果我们想要把暂存区的 <code>readme.txt</code> 文件重置到其他版本的提交也可以通过 <code>git reset SHA</code> 来实现。这个命令是用之前任意一次提交的 <code>SHA</code> 前7位来定位，如：我们第一次提交的 <code>SHA</code> 为 <code>12385fd24ad0cadb2ca6ed4488caae153e3d23b9</code> 那么我们使用的命令为：<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset 12385fd readme.txt</span><br></pre></td></tr></table></figure><p></p><p>为了更好的理解 <code>git reset commit_SHA</code> 我们来看一下下面的图表，每一个圆点代表一次提交。<br><img src="//cdn.jsdelivr.net/gh/summerandwinter/summerandwinter.github.io/assets/images/articles/git-diagram-3.svg" alt="Git HEAD切换"><br>Before reset:</p><ul><li>HEAD 是最近一次提交</li></ul><p>After resetting:</p><ul><li>HEAD 变成了你选择的之前的一次提交</li><li>灰色的提交不再是你项目的一部分</li><li>从本质上改变了项目的历史</li></ul><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p><code>git branch</code> 检查当前所在的分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">* maseter</span><br></pre></td></tr></table></figure><p><code>*</code> 标记当前所在分支</p><p>为了更好的理解Git分支我们看下下面的图表</p><p><img src="//cdn.jsdelivr.net/gh/summerandwinter/summerandwinter.github.ioassets/images/articles/git-diagram-1.svg" alt="Git分支"></p><ul><li>图中的圆点代表提交，所有的提交组成了Git项目的提交历史</li><li>新的分支是不同版本的Git项目，它包含Master的提交，也包含Master所没有的提交</li></ul><p>到目前为止，我们所有的操作都是在单个分支 <code>master</code> 上进行的。<br>下面我们新建一个分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch new_branch</span><br></pre></td></tr></table></figure><p>这里 <code>new_branch</code> 是新分支的名称，名称尽量简短且表明分支的作用，名称中不能含空格。</p><p>现在我们成功的创建了一个新的分支，现在新分支包含了master分支的所有提交历史，接下来我们把当前分支切换到新建的分支<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout new_branch</span><br></pre></td></tr></table></figure><p></p><p>分支切换成功后接下来所有的提交都会提交到新分支 <code>new_branch</code> 而 <code>master</code> 分支不受影响。</p><p>当我们在 <code>new_branch</code> 分支上提交了一些修改后，希望把新分支上的提交同步到 <code>master</code> 中可以通过合并来完成</p><p>首先把当前分支切换到 <code>master</code><br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p></p><p>把新分支合并到 <code>master</code> 分支<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge new_branch</span><br></pre></td></tr></table></figure><p></p><p>当我们使用分支时常常会出现一个问题，我们在两个分支上都做了一些修改，而且这些修改在同一个地方，这种情况下进行合并时，Git无法帮我们决定保留哪个修改，于是Git以冲突的形成告诉我们两个版本的修改中我们重复修改了哪些地方，让我们自己来决定该保留哪个版本的修改。<br>在发生冲突的文件中Git用一些特殊的标记来标识<code>HEAD</code>(master)版本的内容和<code>new_branch</code> 版本的内容,类似下面的方式：<br></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">master version of line</span><br><span class="line">=======</span><br><span class="line">new_branch version of line</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; new_branch</span><br></pre></td></tr></table></figure><p></p><p>选择好需要保留的版本，删除不需要的版本，需要注意的是那些特殊标记如：<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 和 <code>=======</code> 也要删除，不然冲突依然存在。</p><p>通常情况下新建分支的目的是完成项目的一个新特性，当这些特性完成后这个分支的作用也就达到了，当我们把这个分支合并当 <code>master</code> 后，这个分支就可以删除了。<br></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d new_branch</span><br></pre></td></tr></table></figure><p></p><p>上面的命令实现对 <code>new_branch</code> 分支的删除</p><h1 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h1><ul><li><code>git clone</code> 从远程仓库拷贝项目到本地</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> remote_location clone_name</span><br></pre></td></tr></table></figure><ul><li><code>remote_location</code> 告诉Git哪里可以找到远程仓库，通常是一个网址，也可以是一个路径</li><li><p><code>clone_name</code> 告诉Git本地仓库放哪里</p></li><li><p><code>git remote -v</code> 列出Git项目的远程仓库</p></li><li><p><code>git fetch</code> 从远程仓库获取到本地拷贝<br>这个命令不会把远程仓库的修改合并到本地仓库，它会把远程的修改同步到远程分支（remote branch）,此时远程修改还只同步到了（origin/master),本地的master分支还没有更新。</p></li><li><p><code>git merge origin/master</code> 合并 <code>origin/master</code>到本地分支</p></li><li><code>git push</code> 提交本地分支到远程仓库</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin your_branch_name</span><br></pre></td></tr></table></figure><div class="end-of-file">END</div></div><footer class="article-footer"><ul class="article-meta"><li> <span class="label">发布:</span> <a href="/learn-git.html" class="article-date"><time datetime="2016-12-12T13:43:36.000Z" itemprop="datePublished">2016-12-12</time></a></li><li> <span class="label">分类:</span><div class="article-category"> <a class="article-category-link" href="/category/Git/">Git</a></div></li><li> <span class="label">标签:</span><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tag/Git/">Git</a></li></ul></li><hr></ul></footer></div><nav id="article-nav" class="article-nav"> <a href="/imagemagick-learning.html" id="article-nav-newer" class="article-nav-link-wrap newer"><strong class="article-nav-caption">上一篇</strong><div class="article-nav-title"> ImageMagick学习</div></a> <a href="/learn-the-command-line.html" id="article-nav-older" class="article-nav-link-wrap older"><strong class="article-nav-caption">下一篇</strong><div class="article-nav-title">学习Mac命令行</div></a></nav></article><aside id="article-toc" role="navigation" class="article-toc"><div id="article-toc-inner"> <strong class="sidebar-title">目录</strong><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础命令"><span class="toc-text">基础命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Git配置"><span class="toc-text">Git配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#忽略文件"><span class="toc-text">忽略文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取帮助"><span class="toc-text">获取帮助</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取-Git-仓库"><span class="toc-text">获取 Git 仓库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#工作流程"><span class="toc-text">工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#检查状态"><span class="toc-text">检查状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跟踪新文件"><span class="toc-text">跟踪新文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#暂存已修改文件"><span class="toc-text">暂存已修改文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提交更新"><span class="toc-text">提交更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查看提交历史"><span class="toc-text">查看提交历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#移除文件"><span class="toc-text">移除文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#移动文件"><span class="toc-text">移动文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#追踪"><span class="toc-text">追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#撤销对文件的修改"><span class="toc-text">撤销对文件的修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#取消暂存的文件"><span class="toc-text">取消暂存的文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分支"><span class="toc-text">分支</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#团队协作"><span class="toc-text">团队协作</span></a></li></ol> <a href="#" id="article-toc-top">回到顶部</a></div></aside><section id="gitment_ccomments" class="comments"><div id="gitment_container"></div></section></div></section></div><footer id="footer" class="post-footer footer"><div id="footerContent" class="footer-content"><div class="end-of-file">Live Happy Love Hard</div></div></footer></div><script src="//cdn.jsdelivr.net/gh/summerandwinter/summerandwinter.github.io/js/gitment.js"></script><script>var date="Mon Dec 12 2016 13:43:36 GMT+0000",id=""+new Date(date).getTime(),gitment=new Gitment({id:id,owner:"summerandwinter",repo:"summerandwinter.github.io",oauth:{client_id:"7b432b7b46e71966fd88",client_secret:"2c697bec7b012bca975de41c87863d84086f8d81"}});gitment.render("gitment_container")</script><script src="//cdn.jsdelivr.net/gh/summerandwinter/summerandwinter.github.io/js/summer.js"></script><!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]--></div></body>